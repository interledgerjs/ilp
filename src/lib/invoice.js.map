{"version":3,"file":"invoice.js","sourceRoot":"","sources":["invoice.ts"],"names":[],"mappings":"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","sourcesContent":["import BigNumber from 'bignumber.js'\nimport * as crypto from 'crypto'\nimport { STREAM } from '..'\nimport { UnwrappedPromise } from './promise'\nconst createLogger = require('ilp-logger')\nconst log = createLogger('invoice')\n\nexport class Invoice {\n\n  private expectedAmount: BigNumber\n  private ilpAddress: string\n  private sharedSecret: Buffer\n  private connectionTag: string\n  private receivedData: Buffer\n  private paymentPromise: UnwrappedPromise<BigNumber>\n  private dataPromise: UnwrappedPromise<Buffer>\n  private timer?: NodeJS.Timer\n  private streamConnection?: STREAM.Connection\n\n  constructor (amount: BigNumber.Value, streamServer: STREAM.Server) {\n    this.connectionTag = crypto.randomBytes(16).toString('hex')\n    const { destinationAccount, sharedSecret } = streamServer.generateAddressAndSecret(this.connectionTag)\n    this.expectedAmount = new BigNumber(amount)\n    this.ilpAddress = destinationAccount\n    this.sharedSecret = sharedSecret\n    this.receivedData = Buffer.alloc(0)\n    this.dataPromise = new UnwrappedPromise<Buffer>()\n    this.paymentPromise = new UnwrappedPromise<BigNumber>()\n\n    streamServer.on('connection', (connection: STREAM.Connection) => {\n      if (connection.connectionTag === this.connectionTag) {\n        log.debug(`connection opened`)\n        this.streamConnection = connection\n        connection.on('stream', (stream: STREAM.DataAndMoneyStream) => {\n          log.debug(`stream created`)\n          stream.setReceiveMax(amount)\n          stream.on('money', (amountReceived) => {\n            log.trace(`${amountReceived} received`)\n            if (new BigNumber(connection.totalReceived).isGreaterThanOrEqualTo(this.expectedAmount)) {\n              this._complete()\n            }\n          })\n          stream.on('data', (dataReceived) => {\n            log.trace(`${(dataReceived as Buffer).byteLength} bytes of data received`)\n            this.receivedData = Buffer.concat([this.receivedData, dataReceived as Buffer])\n          })\n          stream.on('end', () => {\n            log.debug(`stream ended`)\n            this._complete()\n          })\n        })\n      }\n    })\n  }\n\n  public get address (): string {\n    return this.ilpAddress\n  }\n\n  public get secret (): Buffer {\n    return this.sharedSecret\n  }\n\n  public get data (): Promise<Buffer> {\n    return this.dataPromise.promise\n  }\n\n  public receivePayment (timeout?: number): Promise<BigNumber> {\n    if (timeout) {\n      this.timer = setTimeout(() => {\n        this._timeout()\n      }, timeout)\n    }\n    return this.paymentPromise.promise\n  }\n\n  private _complete () {\n    if (this.timer) {\n      clearTimeout(this.timer)\n    }\n    if (this.streamConnection) {\n      const received = new BigNumber(this.streamConnection.totalReceived)\n      this.paymentPromise.resolve(received)\n      this.dataPromise.resolve(this.receivedData)\n      this.streamConnection.end().catch(e => {\n        log.error('Error closing connection after payment was completed.')\n      })\n    } else {\n      const error = new Error('No incoming STREAM connection.')\n      this.paymentPromise.reject(error)\n      this.dataPromise.reject(error)\n    }\n  }\n\n  private _timeout () {\n    const error = (this.streamConnection)\n    ? new Error(`Timed out waiting for payment. ` +\n      `Received ${this.streamConnection.totalReceived} payment ` +\n      `and ${this.receivedData.byteLength} bytes of data so far.`)\n    : new Error(`Timed out waiting for connection. `)\n\n    this.paymentPromise.reject(error)\n    this.dataPromise.reject(error)\n    if (this.streamConnection) {\n      this.streamConnection.end().catch(e => {\n        log.error('Error closing connection after payment timed out.', e)\n      })\n    }\n  }\n}\n"]}