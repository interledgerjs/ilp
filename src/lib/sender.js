'use strict'

const moment = require('moment')
const Client = require('ilp-core').Client
const debug = require('debug')('ilp:sender')

/**
 * @module Sender
 */

/**
 * Returns an ILP Sender to quote and pay for payment requests.
 *
 * @param  {LedgerPlugin} opts._plugin Ledger plugin used to connect to the ledger, passed to [ilp-core](https://github.com/interledger/js-ilp-core)
 * @param  {Objct}  opts Plugin parameters, passed to [ilp-core](https://github.com/interledger/js-ilp-core)
 * @param  {ilp-core.Client} [opts.client=create a new instance with the plugin and opts] [ilp-core](https://github.com/interledger/js-ilp-core) Client, which can optionally be supplied instead of the previous options
 * @param  {Buffer} [opts.maxHoldDuration=10] Maximum time in seconds to allow money to be held for
 * @return {Sender}
 */
function createSender (opts) {
  const client = opts.client || new Client(opts)

  const maxHoldDuration = opts.maxHoldDuration || 10

  /**
   * Quote a request from a receiver
   * @param  {Object} paymentRequest Payment request generated by an ILP Receiver
   * @return {Promise.<PaymentParams>} Resolves with the parameters that can be passed to payRequest
   */
  function quoteRequest (request) {
    if (!request.address) {
      return Promise.reject(new Error('Malformed payment request: no address'))
    }
    if (!request.amount) {
      return Promise.reject(new Error('Malformed payment request: no amount'))
    }
    if (!request.condition) {
      return Promise.reject(new Error('Malformed payment request: no condition'))
    }

    return client.connect()
      .then(() => client.waitForConnection())
      .then(() => client.quote({
        destinationAddress: request.address,
        destinationAmount: request.amount
      }))
      .then((quote) => {
        debug('got quote response', quote)
        if (!quote) {
          throw new Error('Got empty quote response from the connector')
        }
        return {
          sourceAmount: String(quote.sourceAmount),
          connectorAccount: quote.connectorAccount,
          destinationAmount: String(request.amount),
          destinationAccount: request.address,
          destinationMemo: {
            data: request.data,
            expires_at: request.expires_at
          },
          expiresAt: moment.min([
            moment(request.expires_at),
            moment().add(maxHoldDuration, 'seconds')
          ]).toISOString(),
          executionCondition: request.condition
        }
      })
  }

  /**
   * Get a fixed source amount quote. This is primarily meant to be used in higher level protocols where the sender can request a payment request from the receiver for a specific amount.
   * @param {String} destinationAddress ILP Address of the receiver
   * @param {String|Number} sourceAmount Amount the sender wants to send
   */
  function quoteSourceAmount (destinationAddress, sourceAmount) {
    if (!destinationAddress || typeof destinationAddress !== 'string') {
      return Promise.reject(new Error('Must provide destination address'))
    }
    if (!sourceAmount) {
      return Promise.reject(new Error('Must provide source amount'))
    } 

    return client.connect()
      .then(() => client.waitForConnection())
      .then(() => client.quote({
        destinationAddress: destinationAddress,
        sourceAmount: String(sourceAmount)
      }))
      .then((quote) => {
        debug('got source amount quote response', quote)
        if (!quote) {
          throw new Error('Got empty quote response from the connector')
        }
        return String(quote.destinationAmount)
      })
  }

  /**
   * Pay for a payment request
   * @param  {PaymentParams} paymentParams Respose from quoteRequest
   * @return {Promise.<String>} Resolves with the condition fulfillment
   */
  function payRequest (paymentParams) {
    return client.waitForConnection()
      .then(() => client.sendQuotedPayment(paymentParams))
      .then(() => {
        debug('payment sent', paymentParams)
        return new Promise((resolve, reject) => {
          // TODO just have one listener for the client
          const transferTimeout = setTimeout(() => {
            debug('transfer timed out')
            client.removeListener('outgoing_fulfill', fulfillmentListener)
            reject(new Error('Transfer expired, money returned'))
          }, moment(paymentParams.expiresAt).diff(moment()))

          function fulfillmentListener (transfer, fulfillment) {
            if (transfer.executionCondition === paymentParams.executionCondition) {
              debug('outgoing transfer fulfilled', fulfillment, transfer)
              clearTimeout(transferTimeout)
              resolve(fulfillment)
            }
          }
          client.on('outgoing_fulfill', fulfillmentListener)
        })
      })
  }

  return {
    quoteRequest,
    quoteSourceAmount,
    payRequest
  }
}

exports.createSender = createSender
